---
title: "extra_innings"
author: "Paul A. Hodgetts"
date: "02/03/2021"
output: pdf_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r install packages, echo=FALSE, message=FALSE, warning=FALSE}
# uncomment any packages that need to be installed

# install tidyverse package
# version 1.3.0
#install.packages("tidyverse")         

# install ggplot2 package
# version 3.3.3
#install.packages("ggplot2")           

# install showtext package
# version 0.9-2
#install.packages("showtext")

# install here package
# version 1.0.1
#install.packages("here")

# install Lahman package
# version 8.0-1
#install.packages("Lahman")

# install retrosheet package
# version 1.1.3
#install.packages("retrosheet")
```

```{r libraries, echo=FALSE, message=FALSE, warning=FALSE}
# loads tidyverse library for working with data
# version 1.3.0
library(tidyverse)

# loads ggplot2 library for creating plots
# version 3.3.3
library(ggplot2)

# loads showtext library for accessing Google fonts
# version 0.9-2
library(showtext)

# load here library for working with directories
# version 1.0.1
library(here)

# load Lahman library for baseball data
# version 8.0-1
library(Lahman)

# load retrosheet package for baseball game data
# version 1.1.3
library(retrosheet)
```

```{r font, echo=FALSE, message=FALSE, warning=FALSE}
# add in fonts from Google fonts using showtext package
# font_add_google function calls the font from Google fonts
font_add_google(name = "Roboto Slab", family = "roboto-serif")
# loads font
showtext_auto()
```

```{r data function, echo=FALSE, message=FALSE, warning=FALSE}
# read in the read_gl() function from script directory
source(here::here("script/read_gl.R"))
```

```{r data extra innings, echo=FALSE, message=FALSE, warning=FALSE}
# read in game log datasets using the read_gl function
read_gl("gl2000_x", "data/gl2000_09/GL2000.TXT")
read_gl("gl2001_x", "data/gl2000_09/GL2001.TXT")
read_gl("gl2002_x", "data/gl2000_09/GL2002.TXT")
read_gl("gl2003_x", "data/gl2000_09/GL2003.TXT")
read_gl("gl2004_x", "data/gl2000_09/GL2004.TXT")
read_gl("gl2005_x", "data/gl2000_09/GL2005.TXT")
read_gl("gl2006_x", "data/gl2000_09/GL2006.TXT")
read_gl("gl2007_x", "data/gl2000_09/GL2007.TXT")
read_gl("gl2008_x", "data/gl2000_09/GL2008.TXT")
read_gl("gl2009_x", "data/gl2000_09/GL2009.TXT")
read_gl("gl2010_x", "data/gl2010_19/GL2010.TXT")
read_gl("gl2011_x", "data/gl2010_19/GL2011.TXT")
read_gl("gl2012_x", "data/gl2010_19/GL2012.TXT")
read_gl("gl2013_x", "data/gl2010_19/GL2013.TXT")
read_gl("gl2014_x", "data/gl2010_19/GL2014.TXT")
read_gl("gl2015_x", "data/gl2010_19/GL2015.TXT")
read_gl("gl2016_x", "data/gl2010_19/GL2016.TXT")
read_gl("gl2017_x", "data/gl2010_19/GL2017.TXT")
read_gl("gl2018_x", "data/gl2010_19/GL2018.TXT")
read_gl("gl2019_x", "data/gl2010_19/GL2019.TXT")
read_gl("gl2020_x", "data/gl2020_20/GL2020.TXT")
```

```{r data regular innings, echo=FALSE, message=FALSE, warning=FALSE}
# read in game log datasets using the read_gl function
read_gl("gl2000_r", "data/gl2000_09/GL2000.TXT")
read_gl("gl2001_r", "data/gl2000_09/GL2001.TXT")
read_gl("gl2002_r", "data/gl2000_09/GL2002.TXT")
read_gl("gl2003_r", "data/gl2000_09/GL2003.TXT")
read_gl("gl2004_r", "data/gl2000_09/GL2004.TXT")
read_gl("gl2005_r", "data/gl2000_09/GL2005.TXT")
read_gl("gl2006_r", "data/gl2000_09/GL2006.TXT")
read_gl("gl2007_r", "data/gl2000_09/GL2007.TXT")
read_gl("gl2008_r", "data/gl2000_09/GL2008.TXT")
read_gl("gl2009_r", "data/gl2000_09/GL2009.TXT")
read_gl("gl2010_r", "data/gl2010_19/GL2010.TXT")
read_gl("gl2011_r", "data/gl2010_19/GL2011.TXT")
read_gl("gl2012_r", "data/gl2010_19/GL2012.TXT")
read_gl("gl2013_r", "data/gl2010_19/GL2013.TXT")
read_gl("gl2014_r", "data/gl2010_19/GL2014.TXT")
read_gl("gl2015_r", "data/gl2010_19/GL2015.TXT")
read_gl("gl2016_r", "data/gl2010_19/GL2016.TXT")
read_gl("gl2017_r", "data/gl2010_19/GL2017.TXT")
read_gl("gl2018_r", "data/gl2010_19/GL2018.TXT")
read_gl("gl2019_r", "data/gl2010_19/GL2019.TXT")
read_gl("gl2020_r", "data/gl2020_20/GL2020.TXT")
```

```{r prepare function, echo=FALSE, message=FALSE, warning=FALSE}
# read in the prepare_gl() function from script directory
source(here::here("script/prepare_gl.R"))
```

```{r prepare extra game logs, echo=FALSE, message=FALSE, warning=FALSE}
# use the prepare_gl function to prepare a given gamelog
prepare_gl("gl2000_x", "extra")
prepare_gl("gl2001_x", "extra")
prepare_gl("gl2002_x", "extra")
prepare_gl("gl2003_x", "extra")
prepare_gl("gl2004_x", "extra")
prepare_gl("gl2005_x", "extra")
prepare_gl("gl2006_x", "extra")
prepare_gl("gl2007_x", "extra")
prepare_gl("gl2008_x", "extra")
prepare_gl("gl2009_x", "extra")
prepare_gl("gl2010_x", "extra")
prepare_gl("gl2011_x", "extra")
prepare_gl("gl2012_x", "extra")
prepare_gl("gl2013_x", "extra")
prepare_gl("gl2014_x", "extra")
prepare_gl("gl2015_x", "extra")
prepare_gl("gl2016_x", "extra")
prepare_gl("gl2017_x", "extra")
prepare_gl("gl2018_x", "extra")
prepare_gl("gl2019_x", "extra")
prepare_gl("gl2020_x", "extra")
```

```{r prepare regular game logs, echo=FALSE, message=FALSE, warning=FALSE}
# use the prepare_gl function to prepare a given gamelog
prepare_gl("gl2000_r", "regular")
prepare_gl("gl2001_r", "regular")
prepare_gl("gl2002_r", "regular")
prepare_gl("gl2003_r", "regular")
prepare_gl("gl2004_r", "regular")
prepare_gl("gl2005_r", "regular")
prepare_gl("gl2006_r", "regular")
prepare_gl("gl2007_r", "regular")
prepare_gl("gl2008_r", "regular")
prepare_gl("gl2009_r", "regular")
prepare_gl("gl2010_r", "regular")
prepare_gl("gl2011_r", "regular")
prepare_gl("gl2012_r", "regular")
prepare_gl("gl2013_r", "regular")
prepare_gl("gl2014_r", "regular")
prepare_gl("gl2015_r", "regular")
prepare_gl("gl2016_r", "regular")
prepare_gl("gl2017_r", "regular")
prepare_gl("gl2018_r", "regular")
prepare_gl("gl2019_r", "regular")
prepare_gl("gl2020_r", "regular")
```

```{r dataframe vectors, echo=FALSE, message=FALSE, warning=FALSE}
# create temporary holders for data object names ->
# to be removed later
t1 <- ls(pattern = "_r")
t2 <- ls(pattern = "_x")
```

```{r bind datasets, echo=FALSE, message=FALSE, warning=FALSE}
# create a list of all dataframes
dfx <- grepl("_x", names(.GlobalEnv))
# run twice because it changes the number of items in the global environment-- 
# creating issues for the next line
dfx <- grepl("_x", names(.GlobalEnv))
names(dfx) <- names(.GlobalEnv)

# repeat above steps for regular inning games
dfr <- grepl("_r", names(.GlobalEnv))
dfr <- grepl("_r", names(.GlobalEnv))
names(dfr) <- names(.GlobalEnv)

# bind all extra inning dataframes using the created list
extras <- do.call(rbind, mget(names(dfx)[dfx]))

# bind all regular inning dataframes using the created list
reg <- do.call(rbind, mget(names(dfr)[dfr]))
```

```{r remove data objects, echo=FALSE, warning=FALSE, message=FALSE}
# remove the created game log data objects
rm(list = c(t1, t2))
# remove the temporary vectors ->
# and remove dfr and dfx logical vectors
rm(t1, t2, dfr, dfx)
```

```{r missing values, echo=FALSE, message=FALSE, warning=FALSE}
# read in the check_NA() function from script directory
source(here::here("script/check_NA.R"))

# creates dataset of missing value row and column numbers
check_NA(reg, "reg_NA")
check_NA(extras, "extras_NA")

# remove NAs created by ties
reg <- reg %>% 
  filter(!is.na(winning_team))

extras <- extras %>% 
  filter(!is.na(winning_team))

# doublecheck NA values
check_NA(reg, "reg_NA")
check_NA(extras, "extras_NA")
```

```{r extra inning game win count, echo=FALSE}
# extra inning wins/losses totals
extrawin_count <- count(extras, winning_team)
extrawin_count <- extrawin_count %>% 
  rename(count = n) %>% 
  mutate(game_length = "Extra")

# extra inning wins/losses by year
extra_count_yr <- count(extras, winning_team, year) %>% 
  rename(count = n) %>% 
  unique()
```

```{r regular inning game win count, echo=FALSE}
# regular length wins/losses totals
regwin_count <- count(reg, winning_team)
regwin_count <- regwin_count %>% 
  filter(winning_team != "NA") %>% 
  rename(count = n) %>% 
  mutate(game_length = "Regulation")

# regular length wins/losses by year
reg_count_yr <- count(reg, winning_team, year) %>% 
  filter(winning_team != "NA") %>%
  rename(count = n) %>% 
  unique()
```

```{r combined count, echo=FALSE}
# combine the counts for regulation and extra inning games
combined_counts <- bind_rows(regwin_count, extrawin_count)
```

```{r, echo=FALSE, fig.align = "center", message=FALSE, warning=FALSE}
# generate plot using win counts
ggplot(combined_counts, aes(x = winning_team, y = count, fill = winning_team))+
  # generate bar plot, set alpha to .75
  geom_bar(stat = "identity", alpha = .95)+
  # set plot labels
  labs(x = "Team Identity (Home or Visitor)",                                                     
       y = "Total Game Count",
       fill = "Legend")+
  # set plot theme to minimal
  theme_minimal()+
  # set plot font to roboto-slab-serif
  theme(text = element_text(family = "roboto-serif"),
        # remove minor grid lines
        panel.grid.minor = element_blank(),
        # remove major x grid lines
        panel.grid.major.x = element_blank(),
        # set y grid lines to blue
        panel.grid.major.y = element_line(colour = "#E0EDF5"),
        # set panel spacing to 10mm
        panel.spacing = unit(10, "mm"))+
  # set colour values
  scale_fill_manual(values = c("#00458f", "#f6aa1c"),
                    labels = c("Home", "Visitor"))+
  # set x labels
  scale_x_discrete(labels = c("Home", "Visitor"))+
  # facet wrap by game length
  facet_wrap(vars(game_length),
             scales = "free")
```

```{r, echo=FALSE, fig.height = 7, fig.width = 9, fig.align = "center", message=FALSE, warning=FALSE}
# generate new plot using extra inning wins/losses data
ggplot(extra_count_yr, aes(x = winning_team, y = count, fill = winning_team))+
  # generate bar plot
  geom_bar(stat = "identity", alpha = .95)+
  # set plot labels
  labs(x = "Team Identity (Home or Visitor)",                                                     
       y = "Total Game Count",
       fill = "Legend")+
  # set plot theme to minimal
  theme_minimal()+
  # set plot font to roboto-slab-serif
  theme(text = element_text(family = "roboto-serif"),
        # remove minor grid lines
        panel.grid.minor = element_blank(),
        # remove major x grid lines
        panel.grid.major.x = element_blank(),
        # set major y grid lines to blue
        panel.grid.major.y = element_line(colour = "#E0EDF5"),
        # set panel spacing to 7mm
        panel.spacing = unit(7, "mm"),
        # set legend position to bottom of plot
        legend.position = "bottom",
        # set legend orientation to horizontal
        legend.direction = "horizontal")+
  # set fill values
  scale_fill_manual(values = c("#00458f", "#f6aa1c"),
                    labels = c("Home", "Visitor"))+
  # set x labels
  scale_x_discrete(labels = c("Home", "Visitor"))+
  # set y axis values
  scale_y_continuous(expand = expansion(mult = c(0, 0.05)))+
  # facet wrap by year
  facet_wrap(vars(year),
             nrow = 5,
             scales = "free_y")
```

```{r chart4, echo=FALSE, fig.height = 7, fig.width = 9, fig.align = "center", message=FALSE, warning=FALSE}
# generate new plot using regulation inning wins/losses data
ggplot(reg_count_yr, aes(x = winning_team, y = count, fill = winning_team))+
  # generate bar plot
  geom_bar(stat = "identity", alpha = .95)+
  # set plot labels
  labs(x = "Team Identity (Home or Visitor)",                                                     
       y = "Total Game Count",
       fill = "Legend")+
  # set plot theme to minimal
  theme_minimal()+
  # set plot font to roboto-slab-serif
  theme(text = element_text(family = "roboto-serif"),
        # remove minor grid lines
        panel.grid.minor = element_blank(),
        # remove major x grid lines
        panel.grid.major.x = element_blank(),
        # set y major grid lines to blue
        panel.grid.major.y = element_line(colour = "#E0EDF5"),
        # set panel spacing to 7mm
        panel.spacing = unit(7, "mm"),
        # set legend position to bottom of plot
        legend.position = "bottom",
        # set legend orientation to horizontal
        legend.direction = "horizontal")+
  # set fill values
  scale_fill_manual(values = c("#00458f", "#f6aa1c"),
                    labels = c("Home", "Visitor"))+
  # set x labels
  scale_x_discrete(labels = c("Home", "Visitor"))+
  # set y axis values
  scale_y_continuous(expand = expansion(mult = c(0, 0.05)))+
  # facet wrap by year
  facet_wrap(vars(year),
             nrow = 5,
             scales = "free_y")
```

```{r extra year table, echo=FALSE}
t1 <- extra_count_yr %>% 
  filter(winning_team == "home")
t2 <- extra_count_yr %>% 
  filter(winning_team == "visitor")
t3 <- cbind(t1, t2)

kableExtra::kbl(t3)
rm(t1, t2, t3)
```

```{r regular year table, echo=FALSE}
t1 <- reg_count_yr %>% 
  filter(winning_team == "home")
t2 <- reg_count_yr %>% 
  filter(winning_team == "visitor")
t3 <- cbind(t1, t2)
kableExtra::kbl(t3)
rm(t1, t2, t3)
```

```{r parse retrosheet, eval=FALSE, include=FALSE, echo=FALSE, message=FALSE, warning=FALSE}
# read in the parse_retrosheet_pbp() function from script directory ->
# function from https://github.com/beanumber/baseball_R/blob/master/scripts/parse_retrosheet_pbp.R ->
# has been updated to use here::here()
# data from https://www.retrosheet.org/game.htm
source(here::here("script/parse_retrosheet_pbp.R"))

# create datasets for seasons 2000-2020 ->
# using the parse_retrosheet_pbp() function
parse_retrosheet_pbp(2000)
parse_retrosheet_pbp(2001)
parse_retrosheet_pbp(2002)
parse_retrosheet_pbp(2003)
parse_retrosheet_pbp(2004)
parse_retrosheet_pbp(2005)
parse_retrosheet_pbp(2006)
parse_retrosheet_pbp(2007)
parse_retrosheet_pbp(2008)
parse_retrosheet_pbp(2009)
parse_retrosheet_pbp(2010)
parse_retrosheet_pbp(2011)
parse_retrosheet_pbp(2012)
parse_retrosheet_pbp(2013)
parse_retrosheet_pbp(2014)
parse_retrosheet_pbp(2015)
parse_retrosheet_pbp(2016)
parse_retrosheet_pbp(2017)
parse_retrosheet_pbp(2018)
parse_retrosheet_pbp(2019)
parse_retrosheet_pbp(2020)
```

```{r fields data, echo=FALSE, warning=FALSE, message=FALSE}
# read in fields data ->
# data is from https://github.com/maxtoki/baseball_R/tree/master/data
fields <- read_csv(here::here("data/fields.csv"))
```

```{r season data, echo=FALSE, message=FALSE, warning=FALSE}
# code in this section has been co-opted from chapter nine of Analyzing Baseball Data with R by Marchi, Albert, and Baumer (2018).

##----
# LOAD FANGRAPHS DATA

# create temporary placeholder to hold list of all*.csv files
t1 <- list.files(path = here::here("data"), pattern = ".*all.*\\.csv$")
# create temporary placeholder for df renames
t2 <- c("df2000", "df2001", "df2002", "df2003", "df2004", "df2005",
        "df2006", "df2007", "df2008", "df2009", "df2010", "df2011",
        "df2012", "df2013", "df2014", "df2015", "df2016", "df2017",
        "df2018", "df2019", "df2020")

# for the length of the temporary vector
for(i in 1:length(t1)){
  # assign the matching character string from t2 ->
  # as a dataframe read in using read_csv() from readr ->
  # pull in column names from fields data and Header ->
  # set NA to character
  assign(t2[i], readr::read_csv(here::here("data", t1[i]),
                         col_names = pull(fields, Header), 
                         na = character()) %>%
           dplyr::rename_all(tolower) %>% 
           # mutate new column runs ->
           # new column half_inning ->
           # and new column runs_scored, using mutate() from dplyr
           dplyr::mutate(runs = away_score_ct + home_score_ct,
                  half_inning = paste(game_id, inn_ct, bat_home_id),
                  runs_scored = (bat_dest_id > 3) + (run1_dest_id > 3) +
                    (run2_dest_id > 3) + (run3_dest_id > 3)))
    }
```

```{r runs expectancy matrix, echo=F}
##----
# GENERATE HALF-INNING DATA

# for the length of the temporary vector
for(i in 1:length(t2)){
  # assign to a new data object with suffix _hi
  assign(paste0(t2[i], "_hi"),
         # group by the created half_inning column
         dplyr::group_by(get(t2[i]), half_inning) %>% 
         # summarize outs_inning as sum of event_outs_ct   
         dplyr::summarize(outs_inning = sum(event_outs_ct),
                   # summarize runs_inning as a sum of runs_scored      
                   runs_inning = sum(runs_scored),
                   # summarize runs_start as the first value of runs
                   runs_start = dplyr::first(runs),
                   # summarize max_runs as runs_inning + runs_start
                   max_runs = runs_inning + runs_start))
}


##----
# GENERATE NEXT TEMPORARY HOLDER

# create empty temporary holder
t3 <- c()

# create third temporary holder for "hi" dataset names
# for the length of t2
# paste _hi to the end of the index object
for(i in 1:length(t2)){
  t3[i] =  paste0(t2[i], "_hi")
}


##----
# JOIN HALF-INNINGS DATA TO FULL DATA

# join half_inning data to full season data ->
# for the length of t2
for(i in 1:length(t2)){
  # assign the name at the index location in t2 ->
  # join the object at the index location in t2 with object in t3 ->
  # join by half_inning column
  assign(paste0(t2[i], "_roi"), dplyr::inner_join(get(t2[i]), get(t3[i]), by = "half_inning") %>%
           dplyr::mutate(runs_roi = max_runs - runs) %>% 
           # mutate new column runs in the remainder of inning as ->
           # maxmimum runs - runs
           dplyr::mutate(bases = paste(ifelse(base1_run_id > '', 1, 0),
                                ifelse(base2_run_id > '', 1, 0),
                                ifelse(base3_run_id > '', 1, 0), sep = ""),
                  state = paste(bases, outs_ct),
                  nrunner1 = as.numeric(run1_dest_id == 1 | bat_dest_id == 1),
                  nrunner2 = as.numeric(run1_dest_id == 2 | run2_dest_id == 2 |
                                          bat_dest_id == 2),
                  nrunner3 = as.numeric(run1_dest_id == 3 | run2_dest_id == 3 |
                                          run3_dest_id == 3 | bat_dest_id == 3),
                  nouts = outs_ct + event_outs_ct,
                  new_bases = paste(nrunner1, nrunner2,
                                    nrunner3, sep = ""),
                  new_state = paste(new_bases, nouts)) %>% 
           dplyr::filter((state != new_state) | (runs_scored > 0)))
}


##----
# GENERATE TEMPORARY HOLDER

# create empty temporary holder
t4 <- c()

# create third temporary holder for "hi" dataset names
# for the length of t2
# paste _hi to the end of the index object
for(i in 1:length(t2)){
  t4[i] =  paste0(t2[i], "_roi")
}

# remove data objects with names in t2 and t3
#rm(list = c(t2, t3))

#memory.limit(size = 16000)


##----
# GENERATE PROBABILITY RUN EXPECTANCY CHART FOR AT LEAST 1 RUN

# for the length of t2
for(i in 1:length(t2)){
  # assign a new object with indexed name and suffix _prob ->
  # filter for only 3 out innings
  assign(paste0(t2[i], "_prob1"), dplyr::filter(get(paste0(t2[i], "_roi")), outs_inning == 3) %>%
           # group by state values
           dplyr::group_by(state) %>%
           # calculate the probability of a run given a state as ->
           # the mean of runs_roi when greater than or equal to 1 ->
           # or when at least one run was scored
           dplyr::summarise(run_prob = mean(runs_roi >= 1)))
}


##----
# GENERATE PROBABILITY RUN EXPECTANCY CHART FOR AT LEAST 2 RUNS

# for the length of t2
for(i in 1:length(t2)){
  # assign a new object with indexed name and suffix _prob ->
  # filter for only 3 out innings
  assign(paste0(t2[i], "_prob2"), dplyr::filter(get(paste0(t2[i], "_roi")), outs_inning == 3) %>%
           # group by state values
           dplyr::group_by(state) %>%
           # calculate the probability of a run given a state as ->
           # the mean of runs_roi when greater than or equal to 1 ->
           # or when at least one run was scored
           dplyr::summarise(run_prob = mean(runs_roi >= 2)))
}


##----
# FILTER DATA FOR INNINGS THAT ONLY REACH 3 OUTS

# for the length of t2
for(i in 1:length(t2)){
  # assign new object with indexed t2 name and suffix _ematrix ->
  # filtered from _roi objects for complete innings (outs == 3)
  assign(paste0(t2[i], "_ematrix"), dplyr::filter(get(paste0(t2[i], "_roi")), outs_inning == 3))
}


##----
# GENERATE TEMPORARY HOLDER

t5 <- c()

# create third temporary holder for "hi" dataset names
# for the length of t2
# paste _hi to the end of the index object
for(i in 1:length(t2)){
  t5[i] =  paste0(t2[i], "_ematrix")
}



##----
# GENERATE THE MEAN RUNS ROI AND OUTS DATA

# for the length of t2
for(i in 1:length(t2)){
  # assign new objects with suffix _runs ->
  # grouped by state values in _ematrix objects ->
  assign(paste0(t2[i], "_runs"), dplyr::group_by(get(paste0(t2[i], "_ematrix")), state) %>%
           # use summarise to compute the mean value of runs_roi values ->
           dplyr::summarise(avg = mean(runs_roi)) %>%
           # use mutate to create new outs column ->
           # using substrings of state starting and stopping at position 5 ->
           dplyr::mutate(outs = substr(state, 5, 5)) %>%
           # arrange new object by outs values
           dplyr::arrange(outs))
}


##----
# GENERATE TEMPORARY HOLDER

t6 <- c()

# create third temporary holder for "hi" dataset names
# for the length of t2
# paste _hi to the end of the index object
for(i in 1:length(t2)){
  t6[i] =  paste0(t2[i], "_runs")
}


##----
# GENERATE COMPLETE RUNS EXPECTANCY 24 MATRIX

# for the length of t2
for(i in 1:length(t2)){
  # assign a new object with name of indexed item in t2 ->
  # with suffix _runsout and ->
  # assign new object as a matrix and round values in column 2
  assign(paste0(t2[i], "_re24"), as.matrix(round(get(paste0(t2[i], "_runs"))[2], 2)))
  # assign object under previously used name as a matrix of dimensions 8 rows, 3 columns
  assign(paste0(t2[i], "_re24"), matrix(get(paste0(t2[i], "_re24")), 8, 3))
  # assign object under previously used name and set matrix column names with ->
  # magrittr set_colnames and set matrix row names using magritter set_rownames
  assign(paste0(t2[i], "_re24"), magrittr::set_colnames(get(paste0(t2[i], "_re24")), 
                                                           c("0 outs", "1 out", "2 outs")) %>% 
           magrittr::set_rownames(c("000", "001", "010", "011", "100", "101", "110", "111")))

}

#rm(list = c(t3, t4, t5, t6))
```

```{r simulation matrices, echo=F}
# SIMULATION MATRICES

##----
# GENERATE HALF-INNING DATA

# for the length of the second temporary vector
for(i in 1:length(t2)){
  # assign to a new data object with suffix _hi
  assign(paste0(t2[i], "_hi"),
         # group by the created half_inning column
         dplyr::group_by(get(t2[i]), half_inning) %>% 
         # summarize outs_inning as sum of event_outs_ct   
         dplyr::summarize(outs_inning = sum(event_outs_ct),
                   # summarize runs_inning as a sum of runs_scored      
                   runs_inning = sum(runs_scored),
                   # summarize runs_start as the first value of runs
                   runs_start = dplyr::first(runs),
                   # summarize max_runs as runs_inning + runs_start
                   max_runs = runs_inning + runs_start))
}


# only for use on laptop
#memory.limit(size = 16000)


##----
# JOIN HALF-INNING DATA TO FULL DATASETS

# join half_inning data to full season data ->
# for the length of t2
for(i in 1:length(t2)){
  # assign the name at the index location in t2 ->
  # join the object at the index location in t2 with object in t3 ->
  # join by half_inning column
  assign(paste0(t2[i], "_prep"), dplyr::inner_join(get(t2[i]), get(t3[i]), by = "half_inning") %>%
           # mutate new column runs in the remainder of inning as ->
           # maxmimum runs - runs
           dplyr::mutate(bases = paste(ifelse(base1_run_id > '', 1, 0),
                                ifelse(base2_run_id > '', 1, 0),
                                ifelse(base3_run_id > '', 1, 0), sep = ""),
                  state = paste(bases, outs_ct),
                  nrunner1 = as.numeric(run1_dest_id == 1 | bat_dest_id == 1),
                  nrunner2 = as.numeric(run1_dest_id == 2 | run2_dest_id == 2 |
                                          bat_dest_id == 2),
                  nrunner3 = as.numeric(run1_dest_id == 3 | run2_dest_id == 3 |
                                          run3_dest_id == 3 | bat_dest_id == 3),
                  nouts = outs_ct + event_outs_ct,
                  new_bases = paste(nrunner1, nrunner2,
                                    nrunner3, sep = ""),
                  new_state = paste(new_bases, nouts)) %>% 
           dplyr::filter((state != new_state) | (runs_scored > 0)) %>% 
           dplyr::filter(outs_inning == 3, bat_event_fl == T) %>% 
           dplyr::mutate(new_state = gsub("[0-1]{3} 3", "3", new_state)))
}


##----
# GENERATE TEMPORARY HOLDER

t4 <- c()

# reuse third temporary holder for "prep" dataset names
# for the length of t2
# paste _prep to the end of the index object
for(i in 1:length(t2)){
  t4[i] =  paste0(t2[i], "_prep")
}


##----
# GENERATE TRANSITION MATRICES

# create full transition matrices
for(i in 1:length(t3)){
  assign(paste0(t2[i], "_tmatrix"), 
         dplyr::select(get(t4[i]),
                       state,
                       new_state) %>% 
           table())
}


##----
# GENERATE TEMPORARY HOLDER

t5 <- c()

# reuse third temporary holder for "_tmatrix" table names
# for the length of t2
# paste _tmatrix to the end of the index object
for(i in 1:length(t2)){
  t5[i] =  paste0(t2[i], "_tmatrix")
}


##----
# GENERATE PROBABILITY TABLES FROM TRANSITION MATRICES

# for the length of chr t3
# assign a new probability table matrix with suffix _pmatrix
# then assign a new data object of the same name and bind rows from ->
# the probability table matrix
for(i in 1:length(t3)){
  assign(paste0(t2[i], "_pmatrix"), prop.table(get(t5[i]), 1))
  assign(paste0(t2[i], "_pmatrix"), rbind(get(paste0(t2[i], "_pmatrix")),
                                          c(rep(0, 24), 1)))
}

#rm(list = c(t3, t4, t5, t6))
```

Runs scored $RUNS$ is equal to difference between the sum of runners $N_{runners}$ and outs $O$ before $(b)$ the event plus one and the number of runners $N_{runners}$ plus outs $O$ after $(a)$ after the event.

$$RUNS = (N^{(b)}_{runners} + O^{(b)} + 1) - (N^{(a)}_{runners} + o^{(a)})$$
```{r count function, echo=FALSE}
count_runners_out <- function(.value){
  .value %>%
    stringr::str_split("") %>% 
    purrr::pluck(1) %>% 
    as.numeric() %>% 
    sum(na.rm = T)
}
```

```{r runners out, echo=F}
for(i in 1:length(t3)){
  assign(paste0(t2[i], "_rout"), sapply(row.names(get(paste0(t2[1], "_tmatrix"))),
         count_runners_out))[-25]
}

# reuse third temporary holder for "_pmatrix" table names
# for the length of t2
# paste _pmatrix to the end of the index object
for(i in 1:length(t2)){
  t3[i] =  paste0(t2[i], "_rmatrix")
}

# create runs calculation matrix ->
# for the length of t2 ->
for(i in 1:length(t2)){
  # assign a new object with suffix _rmatrix ->
  # use the outer function to perform the run calculation shown in formula ->
  # runs = nrunnersbefore + outs before + 1 - nrunnersafter + outsafter
  assign(paste0(t2[i], "_rmatrix"), outer(get(paste0(t2[i], "_rout")) + 1, get(paste0(t2[i], "_rout")), FUN = "-"))
  # assign names in tmatrix to rmatrix
  names(t3[1]) <- names(paste0(t2[i], "_tmatrix"))[-25]
  # reassign new rmatrix objects and bind new column
  assign(paste0(t2[i], "_rmatrix"), cbind(get(paste0(t2[i], "_rmatrix")), rep(0, 24)))
}
```

```{r simulate function, echo=F}
sim_half_inning <- function(.tmatrix, .rmatrix, start = 1){
  s <- start
  path <- NULL
  runs <- 0
  while(s < 25){
    s.new <- sample(1:25, size = 1, prob = .tmatrix[s, ])
    path <- c(path, s.new)
    runs <- runs + .rmatrix[s, s.new]
    s <- s.new
  }
  runs
}
```

```{r simulation half inning, echo=FALSE}
set.seed(515)

runs_simulation <- replicate(20000, sim_half_inning(df2019_tmatrix, df2019_rmatrix))

table(runs_simulation)

sum(runs_simulation >= 1) / 20000
mean(runs_simulation)
```

```{r}
p3 <- df2020_pmatrix %*% df2020_pmatrix %*% df2020_pmatrix

p3 %>% 
  as_tibble(rownames = "state") %>% 
  filter(state == "010 0") %>% 
  gather(key = "new_state", value = "prob", -state) %>% 
  arrange(desc(prob)) %>% 
  head()
```
